# Интенсивный мастер-класс "PHP для  начинающих"

## Введение


Все в программировании структурировано, подчиняется логике, **алгоритмизированно**.

Написание программы требует в первую очередь не знания языка, а умения строить логические цепочки, связывать события между собой, т.е. строить алгоритмы.

Для построения алгоритмов рекомендуется использовать блок-схемы. Первое время студентам настоятельно рекомендуется строить блок-схемы даже для самых простых задач, далее - только для тех, которые кажутся им сложными.

## Блок-схемы

**Блок-схемой** называется графическое представление алгоритма. В блок-схеме шаг или последовательность шагов алгоритма представляется в виде блока, а между блоками устанавливаются связи.

Начало и конец алгоритма изображаются скругленными прямоугольниками, обычные действия - прямоугольниками, условия - ромбами, ввод и вывод данных - параллелограммами. Для более подробного ознакомления с блок-схемами читайте [википедию](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA-%D1%81%D1%85%D0%B5%D0%BC%D0%B0) на эту тему.

![](https://www.evernote.com/l/AUblF_ASXpJAZIZA7sJMeHXT-H0gGGIh0TMB/image.png)


## Переменные в PHP: определение, типы данных

**Переменной** называется поименованная область в памяти, где хранятся данные. Переменная имеет тип и имя.
Имена переменных в PHP всегда начинаются со знака доллара. Для того, чтобы создать переменную и записать в нее значение, используется оператор присвоения (=). 
У каждой переменной в php в текущий момент времени может быть только один тип. В конце каждой строки в php надо ставить точку с запятой.

**Типом переменной** называется тот вид данных, который на данный момент может хранить переменная.
Все виды данных в языках программирования можно отнести к двум группам: скалярные (простые) типы данных и структурированные (составные) типы данных.


На этом уроке мы работаем только со скалярным типом данных integer (целые числа) и структурированным типом данных string(строка), представляющим собой последовательность символов. Подробнее структурированные типы данных будут рассмотрены на следующих уроках.

Далее представлены переменные различных скалярных (простых) типов:

```php
$my_integer = 4;     //целые числа
$my_float = 4.12;    //дробные числа
$my_char = 'a';      //символы
$my_bool = true;     //правда или ложь, булева алгебра

```


## Нестрогая динамическая типизация
**PHP - язык с нестрогой динамической типизацией.**

**Динамическая типизация** означает, что одну и ту же переменную можно сначала инициализировать строкой, потом числом, потом булевым значением, и так далее. Языки со статической типизацией, как язык C, Java, подобного не позволяют.

**Нестрогая типизация** означает, что язык сам меняет тип переменной в зависимости от ее использования. К примеру, если прибавить к числу строку, в которой записано число, язык автоматически прибавит число, находящееся в строке. **Нестрогая типизация является причиной многочисленных ошибок.**

## Простейшие математические операции
Над целыми и дробными числами доступны математические операции умножения (+), деления(/), вычитания(-), сложения(+), возведения в степень(**) и получение остатка от деления(%):

```php
$int1 = 4;
$int2 = 8;
$result = $int1 + $int2;  // $result = 12
$result = $int2 - $int1;  // $result = 4
$result = $int1 * $int2;  // $result = 32
$result = $int2 / $int1;  // $result = 2
$result = $int2 ** $int1; // $result = 4096
$result = $int2 % $int1;  // $result = 0
```

## Ввод и вывод данных

Для вывода данных используются функции

`echo, print, print_r, var_dump`

Мы познакомимся с большинством этих функций позже, пока нам достаточно знать следующее:

```php
$int1 = 4;
$str1 = "8";
echo $int1;   //выведет 4
echo 'text'; //выведет text
echo "text"; //выведет text
echo '$str1';//выведет $str1
echo "$str1";//выведет 8
```

# Условия, булева алгебра

Переменная типа `bool` может содержать только два значения: **true** или **false**, при чем это не строки, не числа, а именно понятия ложь и истина.


```php
$bool1 = true;
$bool2 = false;
```  

Для работы с булевыми переменными существует булева алгебра.

## Булева алгебра (логические операторы)

Существуют следующие логические операторы:

* && - И
* || - ИЛИ
* xor - Исключающее ИЛИ
* !  - НЕ

! означает НЕ, и, будучи поставленным перед типом bool, меняет его значение на обратное, т.е. **`! True`** становится **`False`**,**`! False`** становится **`True`**

Далее приведена таблица, демонстрирующая работу операторов:

|             | 0 to 0| 0 to 1| 1 to 0 | 1 to 1|
|-------------|:-----:|:-----:|:------:|:-----:|
| &&          |   0   |   0   |    0   |   1   |
| &#124;&#124;|   0   |   1   |    1   |   1   |
| xor         |   0   |   1   |    1   |   0   |


## Управляющие конструкции
 Простейшая программа выполняется сверху вниз от первой строки к последней. Для того, чтобы изменить порядок выполнения программы, используются управляющие структуры. Существуют управляющие структуры нескольких типов:
 
* операторы условия
* операторы цикла
* операторы подключения других файлов
* операторы для вмешательства в работу цикла или функции прочие операторы
[Полный список](http://php.net/manual/ru/language.control-structures.php)

## Оператор условия if
Существуют следующие операторы условия:

* if -> elseif ->else
* ?: (тернарный оператор)
* switch->case->break

Рассмотрим каждый подробнее на примере конкретного кода:

```php          
<?php

echo "Give it to me!\n";
$handle = fopen ("php://stdin","r");
$number = fgets($handle);

if ($number > 100) {
    echo "Thanks, man!";
} elseif (($number > 10) && ($number < 100)) {
    echo "OK :(";
} else echo "WHAAAAT????";

echo "\n";
if ($number > 1000) echo "\n!!!!WOOOOWWWW!!!\n";

```          

Обратите внимание, мы впервые сталкиваемся с блоком операторов. Так же будет и у циклов, и у функций, и у классов, и у их методов, и так далее. блок операторов начинается со своего инициатора (например, сейчас это блок оператора `if`), после инициатора ставится фигурная скобка, затем все действия, которые программист хочет выполнять в рамках этого блока, он должен выполнять после одного дополнительного отступа. Если отступа не будет, **php** сработает, ошибки не будет, но отступы нужны программисту и его коллегам, чтобы визуально понимать, к какому блоку относится строка кода.

Как видно из листинга, есть возможность применять оператор if в нескольких вариантах. Ниже приведен список всех вариантов:

* if (условие) действие
* if (условие) {блок действий в несколько строк}
* if (условие) {блок действий в несколько строк} else действие
* if (условие) {блок действий в несколько строк} else {блок действий в несколько строк}
* if (условие) {блок действий в несколько строк} elseif(условие) {блок действий в несколько строк} else действие
* if (условие) {блок действий в несколько строк} elseif(условие) {блок действий в несколько строк} else {блок действий в несколько строк}

**Между if и else может быть сколько угодно elseif.**


## Операторы цикла
Существуют следующие операторы цикла:

* while
* do while
* for
* foreach

В большинстве случаев операторы цикла взаимозаменяемы, но у каждого из них есть некоторые ньюансы.

## Оператор while

Простейший оператор цикла while выглядит так:
`while (условие) действие`
или
`while (условие) {блок действий в несколько строк}`

Суть работы цикла: Проверяется условие в цикле, если оно вполняется (т.е. `true`), тело цикла выполняется. Затем опять проверяется условие цикла, если true - выполняется тело, и так до тех пор, пока не перестанет выполняться условие цикла.

```php
$i = 10;
while ($i > 0) {
    echo $i-- . PHP_EOL;
}
```
## Вечный цикл

В программировании довольно часто используются вечные циклы. Просто есть ситуации, когда нет явного ограничения, и условие трудно проверить заранее. Для того, чтобы выйти из вечного цикла, и вообще из цикла, используется оператор `break`. Он работает внутри цикла и прекращает его выполнение. Далее проиллюстрирована работа break и еще пары операторов:

```php
$i = 10;
while (true) {
    if ($i % 2 != 0)
        echo $i . PHP_EOL;
    $i--;
    if ($i % 20 > -19) continue;
    if ($i < -10) break;
}
```

## Цикл for

Цикл `for` представляет собой совмещение трех действий и цикла. В скобках до первой точки с запятой указывается начальное условие или условия, между первой и второй точкой с запятой указывается условие, которое надо проверять перед каждой итерацией цикла, а после второй точки с запятой - действия, который нужно проделать каждый цикл:

```php
$limit = 10;
for ($i=1; $i < $limit + 1; $i++) { 
        echo $i . PHP_EOL;
}
```

Цикл **for** во многом идентичен циклу **while**, если посмотреть на него под определенным углом зрения. По-сути, он так же, как и **while**, проверяет определенное условие, и при его соблюдении запускает очередную итерацию. Что добавляется, так это инициализация переменных до первой итерации (начальные условия) и обязательные каждую итерацию действия. Таким образом, **while** может заменить **for**, а **for** может заменить **while**. Это мы изучим на практике.


## Цикл foreach

Цикл `foreach` представляет собой наиболее удобный способ работы  массивами в `php`. В скобках указывается имя массива, затем, после ключевого слова `as` - пара переменных, разделенных знаком `=>`, первая переменная для ключа массива, вторая - для значения в массиве по этому ключу. Первая переменная не обязательна. Пример:

```php
$a = range(1, 10);
foreach ($a as $key => $value) {
    echo $value . PHP_EOL;
}
```

Также имеется сокращенный вариант цикла `foreach`, применяемый в случае, когда нам не нужны ключи и интересуют нас только значения массива:

```php
$a = range(1, 10);
foreach ($a as $value) {
    echo $value . PHP_EOL;
}
```


## Константы

Если в программе необходимо использовать какое-то число или строку, и программист знает, что эта строка или число не будут меняться в течении времени работы программы, лучше всего использовать константу.

```php
define("LOOP_LIMIT", 10);
define("LOOP_START", 1);
define("MESSAGE", 'Finish!');

$a = range(LOOP_START, LOOP_LIMIT);
foreach ($a as $key => $value) {
    echo $value . PHP_EOL;
}
echo MESSAGE;
```


##Массивы

**Массивы (array)** - структурированный тип данных, являющиейся просто упорядоченой последовательностью других типов данных. В `php`, в отличие от многих других языков, есть всего один вид массивов, совмещающий в себе свойства разных структурных типов данных других языков.

## Создание массивов

Массив чисел без указания индексов или ключей:

```php
$my_array = array(1, 2, 3, 4, 5);
print_r($my_array);

/*Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
*/

// Начиная с PHP 5.4
$array = [1, 2];
```
Массив строк без указания индексов или ключей:

```php
$cars = ['BMW', 'Opel', 'Audi'];
print_r($cars);

/*Array
(
    [0] => BMW
    [1] => Opel
    [2] => Audi
)*/
```
Массив чисел с использованием строкового индекса:

```php
$marks = [
	'Pupkin' => 5,
	'Markov' => 2,
	'Kichev' => 4,
];
print_r($marks);

*/Array
(
    [Pupkin] => 5
    [Markov] => 2
    [Kichev] => 4
)
/*

```

## Операции с массивом

Получение элемента массива, добавление элемента массива:

```php
//добавление элемента в массив
$arr = [1, 2, 3];
$arr[] = 4;
print_r($arr);
/*Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
)
*/

//Получение элемента массива
echo $arr[2]; // выведет 3
```
Двумерный массив и получение вложенного элемента:

```php
$arr = ['z', 'x', ['aa', 'bb']];
print_r($arr);
echo PHP_EOL . $arr[2][0] . PHP_EOL;

/*Array
(
    [0] => z
    [1] => x
    [2] => Array
        (
            [0] => aa
            [1] => bb
        )
)
aa
*/

```
Удаление элемента массива:

```php
$arr = ['x', 'y', 'z', ['aa', 'bb'], '11'];
print_r($arr);
/*Array
(
    [0] => x
    [1] => y
    [2] => z
    [3] => Array
        (
            [0] => aa
            [1] => bb
        )
    [4] => 11
)*/
unset($arr[3]);
print_r($arr);
/*Array
(
    [0] => x
    [1] => y
    [2] => z
    [4] => 11
)*/
```

Удаление массива осуществляется функцией `unset`, примененной к переменной массива.


## Функции для работы с массивами

* `unset` - удаляет массив или элемент массива
* `array_values` - возвращает все значения массива в виде массива
* `array_keys` - возвращает все ключи массива в виде массива
* `array_map` - применяет функцию, имя которой идет первым параметром в кавычках, ко всем элементам массива

Существует огромное количество функций по работе с массивами, ознакомиться с ними можно [здесь ](http://php.net/manual/ru/ref.array.php) или в Google.


##Функции

## Функции php

Программист часто использует встроенные функции языка, и часто пишет свои. Функции языка выглядят как имя функции, за которой в скобках идут параметры функции. 

`результат = имя_функции(параметр1, параметр2...)`

Как правило, функция возвращает какое-то значение в ответ.

Примеры некоторых полезных функций:

```php
$var = 12;

//функция is_int() проверяет, является ли ее параметр целым числом. 
//Возвращает true, если целое число, false, если нет.
echo is_int($var);

//Функция isset($var) проверяет, определена ли переменная
if (isset($var)) echo "It is set"; 

//Функция empty($var) проверяет, не пустая ли переменная
if ( ! empty($var)) echo "It is not empty"; 

//Функции print_r и var_dump осуществляют более подробный вывод
var_dump($var);
print_r($var);
```

## Описание встроенной функции php

Подробное рассмотрение мануала по любой встроенной функции php покажет нам ее описание, подобное следующему:

`int intval ( mixed $var [, int $base = 10 ] )`

Это [описание](http://php.net/manual/ru/function.intval.php) уже знакомой нам функции intval в официальной документации php.
В данном описании функции лева направо: 

* **int** - тип возвращаемого функцией значения. Если void - функция ничего не возвращает.
* **intval** - имя функции.
* **mixed** - тип аргумента. В данном случае - смешанный тип, т.е. возможны разные типы.
* $**var** - аргумент, который передается в функцию.
* **[int $base]** - в квардатных скобках указывается необязательный аргумент. Если перед ним написан тип - то при его передаче тип должен соблюдаться.
* **$base = 10** - если после аргумента идет присвоение ему значения - это его значение по умолчанию. Если аргумент не был передан, ему присваивается значение по умолчанию.

Таким образом из описания выше мы видим, что функция intval возвращает целое число, получает в качестве аргумента один обязательный аргумент смешанного типа и один необязательный, по умолчанию равный десяти.

По ссылке довольно неплохая подборка [встроенных функций](http://site-on.net/create/php/13-built-in-functions).

## Написание своей функции

```php
<?php
function by_tens($number) {
    $i = 10;
    while ($i <= $number) {
        echo "$i\n";
        $i += 10;
    }
    return true;
}
by_tens(120);
}
```

Функция создается с помощью зарезервированного слова `function`. Затем следует имя функции, затем в скобках перечень аргументов функции. После закрывающей скобки перечня аргументов следует блок операторов, аналогичный блоку в `if` или `while`.

Другое зарезервированное слово, важное для создания функций - слово `return`. В теле функции может встречаться сколько угодно операторов `return`. Если выполняется `return`, функция завершает свою работу, возвращая результат вычисления выражения, переданного `return`, как результат работы функции. 
 
## Домашнее задание:
 
 1. Освоить полезные функции для работы с массивами: `range, in_array, shuffle, key, end, reset, array_rand`.
 2. Освоить математические операции деления, понять разницу между функциями округления `floor, ceil, round, intval`.
 3. Освоить операцию остатка от деления `%`.
 4. Написать таблицу Пифагора с выводом в консоль, с использованием двумерного массива и циклов. Попробовать все три варианта циклов. 
 5. Написать функцию, которая получает на вход два числа и ищет результат перемножения этих двух чисел в вашей таблице Пифагора. Вызвать ее 10 раз для разных чисел, результаты вывести.
 6. Вывести только ту часть таблицы Пифагора, у которой четные результаты.
 7. Вывести только ту часть таблицы Пифагора, где четные множители.
 